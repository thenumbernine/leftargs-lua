-- parser needs ; now to know when stmts end ...

print'HelloWorld';
('Hello World') -> print;
local function add(a,b) return a + b end;
(2, 2) -> add;
(add) -> print;
--add -> print;	-- can't remove () ... unless I make -> an expr ... but you can't have single-expr stmts without assignments...
((2, 2) -> add) -> print;
(2, 2) -> add -> print;		-- chaining now works
((2,2) -> add, 2) -> add -> print;

-- how about with indexes:

t={};
t.k=print;
(2,2) -> t.k;
(2,2) -> t['k'];
(t,2,2) -> t['k'];
--(2,2) -> t:k ;	-- not working yet
-- ... but how should successive a:b(1):c(2):d(3) work?
-- ((1) -> a:b):((2)->c):((3)->d)
-- or
-- a:((1)->b):((2)->c):((3)->d)
-- so obj: goes lhs of all, then ((args) -> field)
-- ... should there be an arg similar to : that forwards allll args and not just the first one?  i.e. a:b():::d(4,5) , if a.b returns q,2,3 then q.d is called with q,2,3,4,5 ?
-- building off this it would be good to have vararg-concat operators.  You can also get by with vararg-concat functions.

x = (2,2) -> add;
(x) -> print;
-- here's one selling points: now function inputs are next to lambda outputs ...
x = (2,3) -> (function(x,y) return x^y end);
-- langfix shorthand would look like this:
--x = (2,3) -> ([x,y] x^y);
-- would be nice if I could get rid of the parenthesis ...
(x) -> print;

-- with lambdas ...
--table{116, 101, 115, 116}:mapi([v](v -> string.char)) -> print

-- lambda-input of the table comes right before the lambda-arg of the table `t` without the function body separating them (as with typical right-assoc function args)
-- 		right: 		([t] <function body> )(table{...})) 	vs left:		table{...}->[t] <function body>
-- then the table `mapi` specifies `v` as its argument holding the table-entry, notice it is immediately followed by the `v` that goes into `string.char`, without `string.char` separating the two.
--		right: 		t:mapi([v] string.char[v])				vs left:		t:mapi([v] v->string.char)
--table{116, 101, 115, 116} -> [t] t:mapi([v](v -> string.char)) -> print
